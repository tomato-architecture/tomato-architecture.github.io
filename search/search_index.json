{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tomato Architecture","text":"<p>Tomato Architecture is a pragmatic approach to software architecture following the Core Principles</p>"},{"location":"#background","title":"Background","text":"<p>When I began exploring software architecture, I came across several well-known approaches such as Clean Architecture, The Hexagonal (Ports &amp; Adapters) Architecture, and Onion Architecture. At their core, these architectures share similar goals \u2014 promoting solid software design principles like separation of concerns, testability, and loose coupling.</p> <p>Along with these principles, they also introduced certain practices that made sense for their time. For instance, when integration testing used to be difficult, isolating business logic from framework dependencies and \"programming to interfaces\" were great strategies to enable in-memory or mocked testing. Those ideas worked well for the challenges of that era.</p> <p>However, over time, some of these practices have been taken to extremes. You'll often hear recommendations like:</p> <ul> <li>Your business logic should depend only on the JDK \u2014 no external libraries allowed</li> <li>Create your own logging abstraction</li> <li>Avoid framework annotations and write XML instead to keep your core 'pure'</li> </ul> <p>While these ideas may sound elegant in theory, in practice they often add unnecessary complexity. Modern frameworks and libraries already solve many of these recurring problems. In the real world, companies rarely switch frameworks, databases, or message brokers overnight. Building multiple abstraction layers just to guard against that possibility usually results in more boilerplate and less productivity.</p> <p>I've seen teams implementing Clean, Hexagonal, or Onion architectures spend a surprising amount of time on:</p> <ul> <li>Endless copying of data from one layer to another</li> <li>Creating unnecessary interfaces</li> <li>Creating endless interfaces with only one implementation</li> <li>Re-implementing features (like cross-cutting concerns) that frameworks already handle elegantly.</li> </ul> <p>With the tools we have today \u2014 Mockito for mocking concrete classes, Testcontainers for testing with real dependencies, and frameworks like Spring Boot or Quarkus that already abstract away much of the complexity \u2014 many of these additional layers are simply unnecessary.</p> <p></p> <p>So I decided to take a more pragmatic approach: Keep the timeless principles, embrace modern tooling, and focus on building simple, testable, and maintainable software \u2014 without the dogma or ceremony.</p> <p>That's how Tomato Architecture was born: A blend of the best ideas from existing architectures, minus the cargo-cult, idealistic, and purist mindset.</p>"},{"location":"#core-principles","title":"Core Principles","text":"<ul> <li>Focus on simplicity \u2014 solve today's problems without overengineering for hypothetical future needs.</li> <li>Research, evaluate, and then commit to the right technologies instead of building layers of unnecessary abstraction for the sake of \"future replaceability.\"</li> <li>Design systems that work cohesively as a whole, not just as isolated, well-tested components.</li> <li>Make architectural decisions based on what truly benefits your software \u2014 not merely because it's a trend or endorsed by popular voices.</li> </ul>"},{"location":"#architecture-diagram","title":"Architecture Diagram","text":"<p>A simple layered architecture with strict modularity goes a long way towards achieving the Tomato Architecture goals.</p> <p></p>"},{"location":"#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"#1-package-by-feature","title":"1. Package by feature","text":"<p>A common way to organize code is by technical layers \u2014 separating controllers, services, repositories, and so on. While this approach can work well for a microservice that already represents a single, well-defined business capability, it often becomes cumbersome in larger applications.</p> <p>For monolithic or modular-monolithic architectures, it is strongly recommended to organize code by feature rather than by technical layer. This structure keeps related functionality together, making the codebase easier to navigate, maintain, and evolve.</p> <p>For a deeper dive, check out: https://phauer.com/2020/package-by-feature/</p>"},{"location":"#2-application-core-for-business-logic","title":"2. \"Application Core\" for Business Logic","text":"<p>Keep the Application Core completely independent of any delivery mechanism \u2014 whether it's a web API, scheduled job, or command-line interface.</p> <p>The core should expose well-defined APIs that can be invoked directly from a simple <code>main()</code> method. To achieve this, the Application Core must remain agnostic to its execution context \u2014 it should not depend on HTTP frameworks, web libraries, or any delivery-specific components.</p> <p>Likewise, if the same core logic is reused in scheduled jobs or CLI tools, ensure that scheduling or command execution details never leak into the Application Core.</p>"},{"location":"#3-separation-of-concerns","title":"3. Separation of Concerns","text":"<p>Keep the business logic execution independent of how the input arrives \u2014 whether through web controllers, message listeners, or scheduled jobs.</p> <p>Input sources should act as thin layer to extract the required data from the request source and delegate all business logic to the Application Core.</p> <p>\ud83d\udeab DON'T DO THIS</p> <pre><code>@RestController\nclass CustomerController {\n    private final CustomerService customerService;\n\n    @PostMapping(\"/api/customers\")\n    void createCustomer(@RequestBody Customer customer) {\n       if(customerService.existsByEmail(customer.getEmail())) {\n           throw new EmailAlreadyInUseException(customer.getEmail());\n       }\n       customer.setCreateAt(Instant.now());\n       customerService.save(customer);\n    }\n}\n</code></pre> <p>\u2705 INSTEAD, DO THIS</p> <pre><code>@RestController\nclass CustomerController {\n    private final CustomerService customerService;\n\n    @PostMapping(\"/api/customers\")\n    void createCustomer(@RequestBody Customer customer) {\n       customerService.save(customer);\n    }\n}\n\n@Service\nclass CustomerService {\n   private final CustomerRepository customerRepository;\n\n    @Transactional\n   void save(Customer customer) {\n      if(customerRepository.existsByEmail(customer.getEmail())) {\n         throw new EmailAlreadyInUseException(customer.getEmail());\n      }\n      customer.setCreateAt(Instant.now());\n      customerRepository.save(customer);\n   }\n}\n</code></pre> <p>With this approach, whether a customer is created via REST, CLI, or any other interface, the business logic remains centralized in the Application Core.</p> <p>\ud83d\udeab DON'T DO THIS</p> <pre><code>@Component\nclass OrderProcessingJob {\n    private final OrderService orderService;\n\n    @Scheduled(cron=\"0 * * * * *\")\n    void run() {\n       List&lt;Order&gt; orders = orderService.findPendingOrders();\n       for(Order order : orders) {\n           this.processOrder(order);\n       }\n    }\n\n    private void processOrder(Order order) {\n       ...\n       ...\n    }\n}\n</code></pre> <p>\u2705 INSTEAD, DO THIS</p> <pre><code>@Component\nclass OrderProcessingJob {\n   private final OrderService orderService;\n\n   @Scheduled(cron=\"0 * * * * *\")\n   void run() {\n      List&lt;Order&gt; orders = orderService.findPendingOrders();\n      orderService.processOrders(orders);\n   }\n}\n\n@Service\n@Transactional\nclass OrderService {\n\n   public void processOrders(List&lt;Order&gt; orders) {\n       ...\n       ...\n   }\n}\n</code></pre> <p>This decouples order processing logic from the scheduler, allowing you to test and reuse it independently of any scheduling mechanism.</p> <p>Your Application Core may interact with databases, message brokers, or third-party services \u2014 but ensure these integrations don't leak into your business logic.</p> <p>For example, when using a persistence framework like Spring Data JPA, avoid tying your service logic directly to its APIs.</p> <p>\ud83d\udeab DON'T DO THIS</p> <pre><code>@Service\n@Transactional\nclass CustomerService {\n   private final CustomerRepository customerRepository;\n\n   PagedResult&lt;Customer&gt; getCustomers(Integer pageNo) {\n      Pageable pageable = PageRequest.of(pageNo, PAGE_SIZE, Sort.of(\"name\"));\n      Page&lt;Customer&gt; cusomersPage = customerRepository.findAll(pageable);\n      return convertToPagedResult(cusomersPage);\n   }\n}\n</code></pre> <p>\u2705 INSTEAD, DO THIS</p> <pre><code>@Service\n@Transactional\nclass CustomerService {\n   private final CustomerRepository customerRepository;\n\n   PagedResult&lt;Customer&gt; getCustomers(Integer pageNo) {\n      return customerRepository.findAll(pageNo);\n   }\n}\n\n@Repository\nclass JpaCustomerRepository {\n\n   PagedResult&lt;Customer&gt; findAll(Integer pageNo) {\n      Pageable pageable = PageRequest.of(pageNo, PAGE_SIZE, Sort.of(\"name\"));\n      return ...;\n   }\n}\n</code></pre> <p>This way, changes to your persistence framework or infrastructure only affect the repository layer, leaving your business logic clean and stable.</p>"},{"location":"#4-domain-logic-in-domain-objects","title":"4. Domain logic in domain objects","text":"<p>Keep domain behavior close to the data it operates on \u2014 inside your domain objects.</p> <p>\ud83d\udeab DON'T DO THIS</p> <pre><code>class Cart {\n    List&lt;LineItem&gt; items;\n}\n\n@Service\n@Transactional\nclass CartService {\n\n   CartDTO getCart(UUID cartId) {\n      Cart cart = cartRepository.getCart(cartId);\n      BigDecimal cartTotal = this.calculateCartTotal(cart);\n      ...\n   }\n\n   private BigDecimal calculateCartTotal(Cart cart) {\n      ...\n   }\n}\n</code></pre> <p>In this example, the <code>calculateCartTotal()</code> method contains pure domain logic based solely on the state of <code>Cart</code>. Such logic belongs inside the <code>Cart</code> domain object itself \u2014 not in a service class.</p> <p>\u2705 INSTEAD, DO THIS</p> <pre><code>class Cart {\n    List&lt;LineItem&gt; items;\n\n   public BigDecimal getTotal() {\n      ...\n   }\n}\n\n@Service\n@Transactional\nclass CartService {\n\n   CartDTO getCart(UUID cartId) {\n      Cart cart = cartRepository.getCart(cartId);\n      BigDecimal cartTotal = cart.getTotal();\n      ...\n   }\n}\n</code></pre>"},{"location":"#5-no-unnecessary-interfaces","title":"5. No unnecessary interfaces","text":"<p>Don't create interfaces just because \"we might need another implementation someday.\" If that day ever comes, modern IDEs make it trivial to extract an interface with just a few keystrokes.</p> <p>If your only reason for introducing an interface is to make testing easier \u2014 you don't need to. Mocking frameworks like Mockito can mock concrete classes just fine.</p> <p>In short, only create interfaces when you have a clear and valid reason \u2014 not out of habit or hypothetical future needs.</p>"},{"location":"#6-embrace-frameworks-power-and-flexibility","title":"6. Embrace framework's power and flexibility","text":"<p>Frameworks and libraries are built to solve the common challenges that most applications face. When you adopt one to accelerate development, make full use of its strengths \u2014 embrace it rather than hide it.</p> <p>Creating extra layers of abstraction on top of your chosen framework, just in case you might switch to another someday, is usually counterproductive. It adds complexity without real benefit and often prevents you from leveraging the framework's full potential.</p> <p>For example, the Spring Framework already provides powerful, declarative support for transactions, caching, and method-level security. Re-creating these mechanisms through custom annotations that merely delegate to Spring's features offers no real advantage.</p> <p>Instead, use the framework directly \u2014 or if you need additional semantics, compose your own annotations on top of it, like this:</p> <pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Transactional\npublic @interface UseCase {\n   @AliasFor(\n        annotation = Transactional.class\n   )\n   Propagation propagation() default Propagation.REQUIRED;\n}\n</code></pre> <p>This approach keeps your code expressive while still taking full advantage of the framework's capabilities.</p>"},{"location":"#7-test-not-only-units-but-whole-features","title":"7. Test not only units, but whole features","text":"<p>Unit tests are essential \u2014 they validate individual pieces of business logic, often by mocking external dependencies. But beyond that, it's even more important to ensure that a complete feature actually works as expected.</p> <p>Fast unit tests alone don't guarantee production readiness. To gain real confidence, test your features end-to-end, using real dependencies like databases, message brokers, or external services.</p> <p>The popular idea that \"the core domain must be completely independent of external dependencies\" likely originated when testing with real infrastructure was difficult or impractical. Fortunately, that's no longer the case \u2014 tools like Testcontainers make it easy to spin up real dependencies during tests.</p> <p>Running such tests might take a bit longer, but the confidence and reliability they provide are well worth the trade-off.</p>"},{"location":"concepts/","title":"Concepts","text":"<p>Tomato Architecture is built around the following concepts:</p>"},{"location":"concepts/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<p>A typical web application consists of multiple components such as web controllers, service layers implementing business logic, and database access layers. Separating these components into distinct layers improves maintainability, testability, and extensibility.</p> <p>For example, the web controller should focus on handling incoming HTTP requests and delegating work to the service layer. The service layer implements the business logic and interacts with the persistence layer for data operations.</p>"},{"location":"concepts/#keypoints","title":"Keypoints:","text":"<ul> <li>Web controllers should only extract necessary data from incoming requests and pass it to the service layer.</li> <li>Scheduled jobs should prepare input data from their execution context and delegate actual processing to the service layer.</li> <li>Service layer should expose APIs that execute business use cases as atomic operations.</li> <li>Service layer should remain independent of the context in which it is invoked (e.g., web requests, scheduled jobs, or message listeners).</li> <li>Persistence layer should be solely responsible for database interactions.</li> </ul> <p>For example, the service layer should not look up the current login user details from the HTTP Session or request context. Instead, the web layer should extract user information and pass it to the service layer. This approach makes the service layer reusable across different contexts, such as web requests or background jobs.</p>"},{"location":"concepts/#2-modularity","title":"2. Modularity","text":"<p>Enforcing strict modularity prevents the codebase from devolving into a tightly coupled and unmanageable structure. Organize code by following the package-by-feature approach, where the related feature(s) is encapsulated within its own module.</p> <p>Each module should expose only its public APIs and hide its internal implementation details. This ensures that internal changes within a module do not impact other parts of the system.</p> <p>You can leverage tools such as Spring Modulith and ArchUnit to enforce module boundaries programmatically.</p>"},{"location":"concepts/#3-testability","title":"3. Testability","text":"<p>Automated testing is crucial to maintaining code quality and preventing regressions. A well-structured test suite provides confidence in the stability of the application as it evolves.</p>"},{"location":"concepts/#unit-tests","title":"Unit tests","text":"<p>Unit tests validate individual components\u2014whether a single class or a small cluster of related classes\u2014to ensure they behave as expected. Although mocking dependencies is a common practice, I prefer using real objects whenever possible to keep tests meaningful and closer to real scenarios.</p> <p>When dependencies involve external systems, tools such as Mockito and WireMock can be used to mock interactions.</p> <p>While some developers prefer creating in-memory implementations over using Mockito, IMO, Mockito generally offers greater flexibility and simplicity.</p>"},{"location":"concepts/#integration-tests","title":"Integration tests","text":"<p>While unit tests are valuable for validating isolated logic quickly, integration tests verify that entire features work correctly as a whole.</p> <p>Use Testcontainers to start dependent services and perform realistic end-to-end validation. Though integration tests take longer to run, they provide stronger guarantees that the system behaves correctly in real environments.</p> <p>A healthy combination of both unit and integration tests ensures overall robustness and reliability. While aiming for good test coverage is important, focus on writing meaningful tests that add value rather than chasing arbitrary coverage metrics.</p>"},{"location":"concepts/#4-simplicity-over-excessive-abstractions","title":"4. Simplicity over Excessive Abstractions","text":"<p>Modern frameworks and libraries already address many recurring architectural challenges. In real-world scenarios, organizations rarely switch frameworks, databases, or message brokers overnight. Creating multiple abstraction layers to guard against such unlikely events often leads to unnecessary complexity and reduced productivity.</p> <p>Some interpretations of Hexagonal Architecture discourage direct use of frameworks or libraries, leading developers to reinvent features such as annotations and AOP-based mechanisms (e.g., custom @UseCase annotations for handling transactions or caching). This approach often adds overhead without real benefit.</p> <p>Favor simplicity: minimize coupling with frameworks and libraries but leverage their built-in capabilities when they provide clear value. Avoid reinventing the wheel\u2014use abstractions only when they serve a tangible purpose.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#whats-with-the-name-tomato","title":"What's with the name \"Tomato\"?","text":"<p>The outer layer of a tomato is strong enough to keep its insides together and yet flexible and fluid inside. That perfectly represents how our software should be designed.</p> <p>I am just kidding \ud83d\ude0b You like some made-up fancy words, don't you?</p> <p>If you are okay with \"Hexagonal,\" knowing 6 edges has no significance, you should be okay with \"Tomato\". After all, we have Onion Architecture, why not Tomato Architecture \ud83e\udd13</p>"},{"location":"faq/#i-dont-see-anything-new-in-this-architecture-why-should-i-care","title":"I don't see anything new in this architecture. Why should I care?","text":"<p>Exactly. There's nothing revolutionary here. Tomato Architecture is just taking the good bits from existing architectures and leaving out the cargo-cult rituals. \ud83d\ude07</p>"},{"location":"recommendations/","title":"Recommendations","text":""},{"location":"recommendations/#what-is-your-recommended-tech-stack-for-java-backend-development","title":"What is your recommended tech stack for Java backend development?","text":"<ul> <li>Language: Java / Kotlin</li> <li>Frameworks: Spring Boot, Quarkus</li> <li>Design &amp; Architecture: Modular Monolith, Package-by-Feature</li> <li>Database: PostgreSQL, Flyway Migrations</li> <li>Testing: Integration Tests with Testcontainers, Unit Tests with Mockito, API Stubbing with WireMock</li> <li>Architecture Tests: Spring Modulith Tests, ArchUnit Tests with Taikai</li> <li>Library Upgrades: Renovate, Dependabot, OpenRewrite</li> <li>IDE: IntelliJ IDEA</li> <li>Build Tool: Maven</li> <li>Code Formatting: Spotless Plugin with Palantir Java Format</li> </ul>"},{"location":"recommendations/#unit-vs-integration-tests","title":"Unit vs Integration Tests","text":"<p>I used to strictly follow the Test Pyramid approach, but over time, I've realized that it's not always the most effective strategy. Many of the applications I've worked on have relatively simple business logic but rely heavily on integrations with external systems such as SQL databases, messaging systems, and third-party REST APIs. For such applications, unit tests often provide limited value. Instead, I recommend focusing on integration tests that validate how the application behaves when interacting with real external systems.</p> <p>That said, it's not about choosing only unit tests or only integration tests. The most effective testing strategy involves a balanced mix of different types of tests to ensure comprehensive coverage and reliable behavior.</p> <ol> <li>Integration Tests: Validate the behavior of a feature end-to-end by interacting with real dependencies using tools like Testcontainers. An exception to this is third-party REST APIs, where you can use mocking tools such as WireMock since you may not have control over the external service.</li> <li>Unit Tests: Validate the behavior of a single unit (which could be one class or a group of closely related classes) by mocking external dependencies.</li> <li>Slice Tests: While integration tests are valuable, it's not always necessary to spin up all dependencies for certain scenarios. For example, when testing invalid REST API payloads, you don't need a database or message broker. In such cases, slice tests are ideal \u2014 they load only a subset of components while mocking the rest. In Spring Boot, you can use annotations like <code>@WebMvcTest</code>, <code>@DataJpaTest</code>, and others to achieve this.</li> </ol>"},{"location":"recommendations/#testcontainers-tests-are-taking-too-much-time-what-should-i-do","title":"Testcontainers tests are taking too much time. What should I do?","text":"<ol> <li>Use Testcontainers Singleton approach to use the same containers for all tests.</li> <li>Use Testcontainers reuse feature to keep the containers running in the background instead of stopping and restarting.</li> <li>If you are using Testcontainers with PostgreSQL, consider using dbsandboxer to speed up test execution by using PostgreSQL's template database feature.</li> </ol>"},{"location":"recommendations/#mockito-vs-in-memory-implementation-for-mocking","title":"Mockito vs In-Memory Implementation for Mocking","text":"<p>When writing unit tests for a service layer class(<code>CustomerService</code>), a common challenge is managing its dependencies, such as the <code>CustomerRepository</code>. We need a way to isolate the service logic from the actual data access implementation to ensure the test only validates the service's behavior. Two primary techniques for achieving this isolation are using a mocking framework like Mockito or creating an In-Memory implementation of the dependency.</p> <p>Let's assume the following simplified interfaces and class structures:</p> <pre><code>public class Customer {\n    private Long id;\n    private String name;\n    // ... constructors, getters, and setters\n}\n\npublic interface CustomerRepository {\n    List&lt;Customer&gt; findAll();\n    List&lt;Customer&gt; search(String query);\n    void update(Customer customer);\n    void delete(Long customerId);\n    // ... other methods\n}\n\n@Service\nclass CustomerService {\n    private final CustomerRepository repository;\n\n    public CustomerService(CustomerRepository repository) {\n        this.repository = repository;\n    }\n\n    public List&lt;Customer&gt; findAll() {\n        return repository.findAll();\n    }\n\n    public List&lt;Customer&gt; search(String query) {\n        if (query == null || query.trim().isEmpty()) {\n            return repository.findAll();\n        }\n        return repository.search(query);\n    }\n\n    public void update(Customer customer) {\n        // Assume some business logic here before calling repository\n        repository.update(customer);\n    }\n\n    public void delete(Long customerId) {\n        repository.delete(customerId);\n    }\n}\n</code></pre> <p>Let's explore how we can test using the Mockito-based approach and the In-Memory implementation approach.</p>"},{"location":"recommendations/#testing-with-mockito-mocks","title":"Testing with Mockito Mocks","text":"<p>This approach uses Mockito to create a mock instance of <code>CustomerRepository</code>.</p> <pre><code>import org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass CustomerServiceMockitoTest {\n\n    // Creates a mock instance of CustomerRepository\n    @Mock\n    private CustomerRepository mockRepository;\n\n    // Injects the mockRepository into a CustomerService instance\n    @InjectMocks\n    private CustomerService customerService;\n\n    @Test\n    void search_ShouldReturnFilteredCustomers_WhenQueryIsProvided() {\n        // Arrange: Setup *specific* data for this test\n        String searchName = \"Alice\";\n        List&lt;Customer&gt; expectedCustomers = Arrays.asList(\n            new Customer(1L, \"Alice Smith\"),\n            new Customer(2L, \"Alice Johnson\")\n        );\n\n        // Stubbing: Program the mock to return the *expected* data \n        // when its 'search' method is called with the specific argument.\n        when(mockRepository.search(searchName)).thenReturn(expectedCustomers);\n\n        // Act\n        List&lt;Customer&gt; actualCustomers = customerService.search(searchName);\n\n        // Assert\n        assertEquals(2, actualCustomers.size());\n        assertEquals(\"Alice Smith\", actualCustomers.getFirst().getName());\n\n        // Verification: Ensure the dependency was called as expected\n        verify(mockRepository, times(1)).search(searchName);\n        verify(mockRepository, never()).findAll(); // Ensure findAll wasn't called\n    }\n\n    @Test\n    void delete_ShouldCallRepositoryDelete() {\n        // Arrange\n        Long customerId = 5L;\n\n        // Act\n        customerService.delete(customerId);\n\n        // Assert/Verify\n        // Ensure the delete method on the repository was called exactly once with the correct ID\n        verify(mockRepository, times(1)).delete(customerId);\n    }\n}\n</code></pre> <p>Benefits of the Mockito Approach:</p> <ul> <li> <p>Independent Test Data Setup for Each Test: As shown in the example, you define exactly what the mock returns (stubbing) right before the test execution. This means each test operates with a fresh, isolated set of data. A successful data setup in one test cannot affect the data or assertions of any other test.</p> </li> <li> <p>No Extra Code to Maintain: You do not write a second, simplified implementation of <code>CustomerRepository</code>. All the required \"test behavior\" is defined concisely within the test method itself using the mocking API. This significantly reduces code maintenance overhead.</p> </li> </ul>"},{"location":"recommendations/#testing-with-in-memory-implementation","title":"Testing with In-Memory Implementation","text":"<p>This approach involves creating a concrete implementation of <code>CustomerRepository</code> that stores data in simple Java collections (like <code>List</code> or <code>Map</code>) instead of connecting to a real database.</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.stream.Collectors;\n\nclass InMemoryCustomerRepository implements CustomerRepository {\n    // This collection holds the data for testing\n    private final Map&lt;Long, Customer&gt; store = new ConcurrentHashMap&lt;&gt;();\n    private final AtomicLong nextId = new AtomicLong(1);\n\n    public void saveInitialData(List&lt;Customer&gt; customers) {\n        store.clear(); // Important: clear data before each setup\n        customers.forEach(c -&gt; {\n            c.setId(nextId.getAndIncrement());\n            store.put(c.getId(), c);\n        });\n    }\n\n    @Override\n    public List&lt;Customer&gt; findAll() {\n        return new ArrayList&lt;&gt;(store.values());\n    }\n\n    @Override\n    public List&lt;Customer&gt; search(String query) {\n        return store.values().stream()\n                .filter(c -&gt; c.getName().contains(query))\n                .collect(Collectors.toList());\n    }\n\n    // Simplified implementation for the test\n    @Override\n    public void update(Customer customer) {\n        store.put(customer.getId(), customer);\n    }\n\n    @Override\n    public void delete(Long customerId) {\n        store.remove(customerId);\n    }\n}\n</code></pre> <p>The test relies on setting up the shared data structure in the <code>InMemoryCustomerRepository</code>.</p> <pre><code>import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass CustomerServiceInMemoryTest {\n\n    private InMemoryCustomerRepository inMemoryRepository;\n    private CustomerService customerService;\n\n    @BeforeEach\n    void setup() {\n        inMemoryRepository = new InMemoryCustomerRepository();\n        customerService = new CustomerService(inMemoryRepository);\n\n        // Initial setup for ALL tests using this repository\n        List&lt;Customer&gt; initialData = Arrays.asList(\n            new Customer(null, \"Charlie Brown\"),\n            new Customer(null, \"Alice Smith\"),\n            new Customer(null, \"David Jones\")\n        );\n        inMemoryRepository.saveInitialData(initialData);\n    }\n\n    @Test\n    void search_ShouldReturnFilteredCustomers_WhenQueryIsProvided() {\n        // Arrange is done in @BeforeEach, we rely on the initial data.\n\n        // Act\n        List&lt;Customer&gt; actualCustomers = customerService.search(\"li\");\n\n        // Assert\n        assertEquals(1, actualCustomers.size());\n        assertEquals(\"Charlie Brown\", actualCustomers.get(0).getName());\n    }\n}\n</code></pre> <p>Problems with the In-Memory Repository Approach:</p> <p>While an in-memory repository can feel more \"real\" than a mock, it introduces significant issues for unit testing:</p> <p>1. Need to Maintain Two Versions of the Repository Implementations: You must keep the production code (e.g., Spring Data JPA implementation) and the <code>InMemoryCustomerRepository</code> perfectly compatible. Every time a method is added or the behavior of an existing method is changed (e.g., subtle ordering or filtering logic), both implementations must be updated. This creates a maintenance burden and a risk of divergence (where the in-memory version doesn't accurately reflect the production version).</p> <p>2. Test Execution Order Matters (Shared State Problem): The in-memory repository keeps data in a shared collection (<code>List&lt;Customer&gt;</code> or <code>Map&lt;Long, Customer&gt;</code>). If one test modifies this shared state (e.g., a delete test), that modification persists and can affect subsequent tests. For example, a search test that relies on 5 records being present will fail if a preceding delete test removed one of them. While a <code>@BeforeEach</code> method can help reset the state, managing complex, multi-state resets quickly becomes cumbersome and brittle.</p> <p>3. Brittle Test Data Setup: As the application grows and more functionality is added, maintaining a global data set for the in-memory repository becomes extremely difficult.</p> <p>For example, a test verifying a feature expects a search query to return 23 records based on the current global data setup. If new data is added for a different test or feature, and that new data also matches the search criteria, the count might become 24. The original test's assertion (<code>assertEquals(23, actualCount)</code>) will fail, even though the service logic itself is correct. The test setup becomes hard to maintain as the application expands.</p> <p>So, I recommend using Mockito so that you control the exact conditions of the test without the maintenance overhead and brittleness associated with managing a secondary, in-memory dependency implementation.</p>"},{"location":"recommendations/#should-i-aim-for-100-test-coverage","title":"Should I aim for 100% Test Coverage?","text":"<p>Striving for 100% test coverage often leads to a blind ritual rather than a genuine pursuit of quality. While the metric was intended to encourage thorough testing, obsessively chasing the final few percentage points frequently results in writing trivial, brittle tests that simply confirm getter/setter calls or other low-value code, without actually verifying meaningful system behavior. </p> <p>The reality is that high test coverage doesn't necessarily mean high-quality code; a project can have 100% coverage yet still fail to test critical business logic or edge cases. </p> <p>Instead of a rigid target, a more pragmatic approach is to aim for a solid foundation, such as 80% code coverage, prioritizing a good test suite focused on verifying system behavior, complex logic, and integration points, which provides the most value for maintaining a robust application.</p>"},{"location":"recommendations/#how-to-enforce-a-common-coding-style-in-a-team","title":"How to enforce a common coding style in a team?","text":"<p>Code formatting and linting are frequently discussed \u2014 and sometimes hotly debated \u2014 topics within development teams. In reality, these discussions often consume more time than they should. Once a team agrees on a standard formatting approach, it typically becomes second nature within a week, and few developers think about it again.</p> <p>To maintain consistency and avoid unnecessary debates, it\u2019s best to adopt a well-established tool and automate formatting as part of your build or CI process. Some popular options include:</p> <ul> <li>Spotless</li> <li>Google Java Format</li> <li>Spring Java Format</li> <li>Prettier Java</li> </ul>"},{"location":"spring-boot-impl/","title":"Tomato Architecture - Spring Boot","text":"<ul> <li>A reference implementation of Tomato using Spring Boot.</li> </ul> <p>https://github.com/tomato-architecture/tomato-architecture-spring-boot-demo</p> <ul> <li>A multi-module Spring Boot application supporting WebApp, REST API, and CLI.</li> </ul> <p>https://github.com/tomato-architecture/url-shortener-tomato-architecture</p>"}]}